<!DOCTYPE html>
<html>
<head>
    <title>unkm.fr</title>
    <meta charset="utf-8" />
    <meta name="description" content="Visualisez rapidement ce que représentent 1km autour de chez vous." />
    <meta property="og:image" content="https://www.unkm.fr/unkm.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5AByqwEy0P">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5AByqwEy0P">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5AByqwEy0P">
    <link rel="manifest" href="/site.webmanifest?v=5AByqwEy0P">
    <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5AByqwEy0P" color="#b91d47">
    <link rel="shortcut icon" href="/favicon.ico?v=5AByqwEy0P">
    <meta name="msapplication-TileColor" content="#b91d47">
    <meta name="theme-color" content="#b91d47">    
    <link rel="stylesheet" href="ressources/leaflet.css"/>
    <style>
        body { padding: 0; margin: 0; font-family: 'Roboto', arial, 'Segoe UI', 'Roboto', arial, system-ui, BlinkMacSystemFont, 'Roboto', arial, sans-serif; }
        html, body, #map { height: 100%; width: 100%; }
        h4 { padding: 5px; margin: 5px; }
        #info { position: fixed; z-index: 1000; top: 50%; left: 50%; margin-top: -80px; margin-left: -252px; height: 160px; width: 500px; text-align: center; border: 2px solid #f07300; background-color: rgba(255, 255, 255, 0.8); font-size: 18px; cursor: pointer; }
        #info > a { font-size: 12px; color: #f07300; }
        @media (max-width: 480px) { #info { margin-top: -60px; margin-left: -182px; height: 120px; width: 360px; font-size: 14px; } }
        .buttons {position: fixed; z-index: 1000; left: 10px; height: 50px; width: 50px; }
        #help { bottom: 50px; text-align: center; border-radius: 50%; background-color: #f07300; font-size: 20px; cursor: pointer; }
        #help > p { margin: 10px; font-size: 22px; font-weight: bolder; color: white; }
        .share { fill: #f07300;  stroke: none; border-radius: 50%; background-color: #fff; }
        #share-facebook { bottom: 170px; }
        #share-twitter { bottom: 110px; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="help" class="buttons"><p>?</p></div>
    <a id="share-facebook" class="buttons share" href="https://facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.unkm.fr" target="_blank" rel="noopener" aria-label="">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 0C5.38 0 0 5.38 0 12s5.38 12 12 12 12-5.38 12-12S18.62 0 12 0zm3.6 11.5h-2.1v7h-3v-7h-2v-2h2V8.34c0-1.1.35-2.82 2.65-2.82h2.35v2.3h-1.4c-.25 0-.6.13-.6.66V9.5h2.34l-.24 2z"/></svg>
    </a>
    <a id="share-twitter" class="buttons share" href="https://twitter.com/intent/tweet/?text=Visualisez%20rapidement%20ce%20que%20repr%C3%A9sentent%201km%20autour%20de%20chez%20vous.&amp;url=https%3A%2F%2Fwww.unkm.fr" target="_blank" rel="noopener" aria-label="">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 0C5.38 0 0 5.38 0 12s5.38 12 12 12 12-5.38 12-12S18.62 0 12 0zm5.26 9.38v.34c0 3.48-2.64 7.5-7.48 7.5-1.48 0-2.87-.44-4.03-1.2 1.37.17 2.77-.2 3.9-1.08-1.16-.02-2.13-.78-2.46-1.83.38.1.8.07 1.17-.03-1.2-.24-2.1-1.3-2.1-2.58v-.05c.35.2.75.32 1.18.33-.7-.47-1.17-1.28-1.17-2.2 0-.47.13-.92.36-1.3C7.94 8.85 9.88 9.9 12.06 10c-.04-.2-.06-.4-.06-.6 0-1.46 1.18-2.63 2.63-2.63.76 0 1.44.3 1.92.82.6-.12 1.95-.27 1.95-.27-.35.53-.72 1.66-1.24 2.04z"/></svg>
    </a>
    <div id="info">
      <h4>Comment ça marche ?</h4>
      Zoomez sur votre lieu de confinement<br />
      Cliquez pour dessiner un cercle de 1km de rayon*<br /><br />
      Vous pouvez aussi vous <button id="gelocation">géolocaliser</button><br />
	  <a href="https://www.legifrance.gouv.fr/affichTexte.do?cidTexte=LEGITEXT000041747861">* texte de loi en vigueur</a>
    </div>
    <script src="ressources/leaflet.js"></script>
    <script>
      var map = L.map('map').setView([46.71109, 1.7191036], 6);
      mapLink = '<a href="https://openstreetmap.org">OpenStreetMap</a> | <a href="mentions-legales.txt">Mentions légales</a>';
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: 'Map data &copy; ' + mapLink, maxZoom: 18}).addTo(map);
      L.control.scale().addTo(map);

      map.on('click', helpHide);
      map.on('movestart', helpHide);
      map.on('zoomstart', helpHide);
      document.getElementById("info").onclick = helpHide;
      document.getElementById("help").onclick = helpDisplay;
      document.getElementById("gelocation").onclick = geolocationRequest;



      function helpHide(e) {
        document.getElementById("info").style.display = "none";
        map.on('click', locationUpdate);
      }

      function helpDisplay(e) {
        document.getElementById("info").style.display = "block";
      }

      function geolocationRequest() {
        map.locate({setView: true, maxZoom: 14, enableHighAccuracy: true});
        map.on('locationfound', geolocationFound);
      }

      function geolocationFound(e) {
        locationUpdate(e);
      }

      var clickCircle;
      var clickMarker;
      function displayCircle(e) {
        if (clickCircle != undefined) { map.removeLayer(clickCircle); };
        if (clickMarker != undefined) { map.removeLayer(clickMarker); };
        clickCircle = L.circle(e.latlng, 1000, { color: '#f07300', fillOpacity: 0.1, opacity: 0.5}).addTo(map);
        clickMarker = L.marker(e.latlng).addTo(map);
        window.center = e.latlng;
      }
      
      function getNodesInside(elements, center) {
        var result = {};
        
        for(var i = 0; i != elements.length; ++i) {
            if (elements[i].type == "node") {
                var p = L.latLng(elements[i].lat, elements[i].lon);
                if (p.distanceTo(window.center) < 1000) {
                    result[elements[i].id] = p;
                    result[elements[i].id].neighbours = [];
                    result[elements[i].id].id = elements[i].id;
                }
            }
        }

        return result;
      }
      
      function buildGraphInside(elements, nodes) {
        var result = [];
        for(var i = 0; i != elements.length; ++i) {
            if (elements[i].type == "way" || elements[i].type == "pathway") {                
                if (elements[i].nodes.length > 1) {
                    for(var n = 1; n != elements[i].nodes.length; ++n) {
                        var idN = elements[i].nodes[n];
                        var idNm1 = elements[i].nodes[n - 1];
                        if (idNm1 in nodes && idN in nodes) {
                            result.push([parseInt(idNm1), parseInt(idN)]);
                            var idE = result.length - 1;
                            nodes[idNm1].neighbours.push({ node: idN, edge: idE});
                            nodes[idN].neighbours.push({ node: idNm1, edge: idE});
                        }
                    }
                }
            }
        }

        return {nodes: nodes, edges: result};
      }
      
      
      function filterBySelectedEdges(graph, edges) {
        var newNodes = {};
        
        // create the set of new nodes
        for(var e = 0; e != edges.length; ++e) {
            newNodes[edges[e][0]] = graph.nodes[edges[e][0]];
            newNodes[edges[e][1]] = graph.nodes[edges[e][1]];
            newNodes[edges[e][0]].neighbours = [];
            newNodes[edges[e][1]].neighbours = [];
        }
        
        // for each node, create the neighbours list
        for(var e = 0; e != edges.length; ++e) {
            newNodes[edges[e][0]].neighbours.push({ node: edges[e][1], edge: e});
            newNodes[edges[e][1]].neighbours.push({ node: edges[e][0], edge: e});
        }

        return { nodes: newNodes, edges: edges };
      }
      
      // compute a pseudo angle defined by a polyline (n1, n2, n3)
      function computeAngle(n1, n2, n3) {      
        var v1 = [n2.lat - n1.lat, n2.lng - n1.lng];
        var v2 = [n3.lat - n2.lat, n3.lng - n2.lng];
        var dot = v1[0] * v2[0] + v1[1] * v2[1];
        var det = v1[0] * v2[1] - v1[1] * v2[0];
        return Math.atan2(det, dot);

      }
      
      function findNextOnRegion(pred, current, nodes) {
        var predNode = nodes[pred];
        var curNode = nodes[current];
        // if it is a dead-end, we go back to the 
        if (curNode.neighbours.length == 1) {
            return pred;
        }
      
        var bestNode = -1;
        var angle = 0;
        for(var v = 0; v != curNode.neighbours.length; ++v) {
            var n = curNode.neighbours[v];
            if (pred != n.node) {
                var mAngle = computeAngle(predNode, curNode, nodes[n.node]);
                if (bestNode < 0 || mAngle < angle) {
                    bestNode = n.node;
                    angle = mAngle;
                }
            }
        }
        if (bestNode == -1)
            console.log("ERROR: cannot find next point");
        return bestNode;
      
      }
      
      
      function getGraphLoopFromEdge(line, graph) {
        var result = [];
        
        var pred = line[0];
        var current = line[1];
        
        // build the edges
        do {
            var next = findNextOnRegion(pred, current, graph.nodes);
            result.push([current, next]);
            pred = current;
            current = next;
            
        } while ((pred != line[0]) || (current != line[1]));
        
        return filterBySelectedEdges(graph, result);
      }
      
      
      function getLongitudeCrossing(lat, edge, nodes) {
        var lat1 = nodes[edge[0]].lat;
        var lat2 = nodes[edge[1]].lat;
        var lng1 = nodes[edge[0]].lng;
        var lng2 = nodes[edge[1]].lng;
        
        if (lat1 > lat2) {
            console.log("ERROR: wrong orientation");
        }
        
        return lng1 + (lng2 -lng1) / (lat2 - lat1) * (lat - lat1);
      
      }
      
      function getContourEdge(graph) {
        var edges = graph.edges;
        var nodes = graph.nodes;
        var lat = window.center.lat;
        var crossings = [];
        
        // get all the edges that are crossing the line defined by the lattitude of the center
        for(var l = 0; l != edges.length; ++l) {
            if (nodes[edges[l][0]].lat <= lat && nodes[edges[l][1]].lat > lat) {
                crossings.push({edge: edges[l], coord: getLongitudeCrossing(lat, edges[l], nodes) });
            }
            else if (nodes[edges[l][1]].lat <= lat && nodes[edges[l][0]].lat > lat) {
                crossings.push({edge: [edges[l][1], edges[l][0]], coord: getLongitudeCrossing(lat, [edges[l][1], edges[l][0]], nodes) });
            }
        }
        
        if (crossings.length == 0) {
            console.log("ERROR: cannot find a contour edge");
            return null;
        }
        // find the smallest longitude
        var result = 0;
        var longitude = crossings[result].coord;
        for(var i = 0; i < crossings.length; ++i) {
            if (crossings[i].coord < longitude) {
                result = i;
                longitude = crossings[i].coord;
            }
        }
        
        return crossings[result].edge;
      
      }
      
      
      function getContour(graph) {
        
        var contourEdge = getContourEdge(graph);
        if (contourEdge == null)
            return null;
        
        return getGraphLoopFromEdge(contourEdge, graph);
      }
      
      function browseCC(nodeID, graph) {
        graph.nodes[nodeID].seen = true;
        var result = { edges: [], size: 0 };
        for(var nb = 0; nb != graph.nodes[nodeID].neighbours.length; ++nb) {
            var neighbour = graph.nodes[nodeID].neighbours[nb].node;
            var edge = graph.nodes[nodeID].neighbours[nb].edge;
            // to avoid multiple instances of an edge, only add it from the first node
            if (graph.edges[edge][0] == nodeID)
                result.edges.push(graph.edges[edge]);
            // then use recursive call if required
            if (!graph.nodes[neighbour].seen) {                
                result.size += graph.nodes[nodeID].distanceTo(graph.nodes[neighbour]);
                var run = browseCC(neighbour, graph);
                result.edges = result.edges.concat(run.edges);
                result.size += run.size;
            }
        }
        
        return result;
      }
      
      function keepMainCC(graph) {
        var cc = [];
        
        for(var n in graph.nodes) {
            graph.nodes[n].seen = false;
        }
        
        
        // compute connecte component size
        for(var n in graph.nodes) {
            n = parseInt(n);
            if (!graph.nodes[n].seen) {
                cc.push(browseCC(n, graph));
            }
        }
        
        if (cc.length == 0)
            return null;
        
        // select the largest one
        var idCC = 0;
        var size = cc[idCC].size;
        for(var i = 1; i != cc.length; ++i) {
            if (cc[i].size > size) {
                idCC = i;
                size = cc[i].size;
            }
        }
        return filterBySelectedEdges(graph, cc[idCC].edges);
      }
      
      
      function removeDoubleEdges(graph) {
      
        var edges = {};
        
        for(var e = 0; e != graph.edges.length; ++e) {
            var edge = graph.edges[e];
            if (edge[0] < edge[1]) {
                var v = edge[0];
                edge[0] = edge[1];
                edge[1] = v;
            }
            var str = edge[0] + "," + edge[1];
            if (str in edges) {
                delete edges[str];
            }
            else {
                edges[str] = edge;
            }
        }
        var flatEdges = [];
        for(var e in edges) {
            flatEdges.push(edges[e]);
        }
        
        return filterBySelectedEdges(graph, flatEdges);
      }
      
      function toPolyLine(edge, nodes) {
        return [[nodes[edge[0]].lat, nodes[edge[0]].lng], [nodes[edge[1]].lat, nodes[edge[1]].lng]];
      }
      
      window.ClickCircularPaths = [];
      function displayCircularPath(e) {
        if (window.ClickCircularPaths.length != 0) { 
            for(var p = 0; p != window.ClickCircularPaths.length; ++p) {
                map.removeLayer(window.ClickCircularPaths[p]); 
            }
        }
        var square = clickCircle.getBounds();
        var bboxString = square.getSouth() + "," + square.getWest() + ", " + square.getNorth() + "," + square.getEast();
        
        var query = "[out:json][timeout:25];(way[\"highway\"][\"highway\"!~\"motorway\"](" + bboxString + ");way[\"pathway\"](" + bboxString + "););out;>;out skel qt;";
        
        var server = "https://overpass.kumi.systems/api/interpreter";
        
        var request = new XMLHttpRequest();
                
        request.open('GET', server + "?data=" + encodeURIComponent(query), true);
        request.setRequestHeader('Content-type', 'application/json');

        request.addEventListener("load", function() { 
            var response = JSON.parse(request.response);
            
            // get only nodes inside the disc
            var nodes = getNodesInside(response.elements);
            
            // get all edges inside the disc
            var graph = buildGraphInside(response.elements, nodes);
                                                                    
            // select the largest connected component (not perfect to select the main path, but should be ok)
            graph = keepMainCC(graph);

            // build a polygon corresponding to the contour
            var contourGraph = getContour(graph);

            if (contourGraph != null) {
    
                // remove edges twice in the shape
                contourGraph = removeDoubleEdges(contourGraph);
    
                // select the largest connected component (not perfect to select the main path, but should be ok)
                contourGraph = keepMainCC(contourGraph);
                
                if (contourGraph != null) {
                    // draw the contour
                    for(var e = 0; e != contourGraph.edges.length; ++e) {
                        window.ClickCircularPaths.push(L.polyline(toPolyLine(contourGraph.edges[e], contourGraph.nodes), { color: '#0060f0'}).addTo(map));
                    }
                }
            }
            
        });
        request.send();
        
      }
      
      function locationUpdate(e) {
        if(e) {
          if(map.getZoom() < 12) {return;};
          window.location.hash = e.latlng.lat+','+e.latlng.lng;
        }
        var lPos = window.location.hash.substring(1).split(',');
        if(typeof window.location.hash != "undefined" && window.location.hash.length > 5 &&
            window.hashpos != lPos) {
          window.hashpos = lPos;
          var event = {latlng: L.latLng(window.hashpos[0], window.hashpos[1])}
          map.setView(event.latlng, 15);
          displayCircle(event);
          displayCircularPath(event);
          helpHide();
        }
      }
      window.hashpos = "";
      window.onhashchange = locationUpdate();
      locationUpdate();
      
      

      
    </script>
</body>
</html>
